<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WorkSlots</title>
    <link rel="icon" type="image/svg+xml" href="icon.svg" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              neutral: {
                50: "var(--neutral-50)",
                100: "var(--neutral-100)",
                200: "var(--neutral-200)",
                300: "var(--neutral-300)",
                400: "var(--neutral-400)",
                500: "var(--neutral-500)",
                600: "var(--neutral-600)",
                700: "var(--neutral-700)",
                800: "var(--neutral-800)",
                900: "var(--neutral-900)",
              },
              primary: {
                50: "var(--primary-50)",
                100: "var(--primary-100)",
                200: "var(--primary-200)",
                300: "var(--primary-300)",
                400: "var(--primary-400)",
                500: "var(--primary-500)",
                600: "var(--primary-600)",
                700: "var(--primary-700)",
                800: "var(--primary-800)",
                900: "var(--primary-900)",
              },
              surface: {
                DEFAULT: "var(--surface)",
                hover: "var(--surface-hover)",
              },
              "on-primary": "var(--on-primary)",
              "on-toast": "var(--on-toast)",
              danger: {
                DEFAULT: "var(--danger)",
                light: "var(--danger-light)",
                hover: "var(--danger-hover)",
              },
              overlay: "var(--overlay)",
            },
          },
        },
      };
    </script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap");

      /* ── Light Mode (Cool Greige) ── */
      :root {
        --neutral-50: #f8f7f5;
        --neutral-100: #f0eeeb;
        --neutral-200: #d8d3cd;
        --neutral-300: #c0b9b0;
        --neutral-400: #a09890;
        --neutral-500: #7a736b;
        --neutral-600: #5c5650;
        --neutral-700: #4a433c;
        --neutral-800: #3a3530;
        --neutral-900: #33302c;

        --primary-50: #f0eeeb;
        --primary-100: #e0dbd5;
        --primary-200: #c0b5a8;
        --primary-300: #a89888;
        --primary-400: #8d7b6a;
        --primary-500: #7a6b5c;
        --primary-600: #6e5f50;
        --primary-700: #5c4f42;
        --primary-800: #4a3f35;
        --primary-900: #3a3128;

        --surface: #ffffff;
        --surface-hover: #fafaf8;
        --on-primary: #ffffff;
        --on-toast: #ffffff;
        --overlay: rgba(0, 0, 0, 0.5);
        --danger: #dc2626;
        --danger-light: #fef2f2;
        --danger-hover: #f87171;
        --neutral-50-alpha: rgba(248, 247, 245, 0.5);
        --ring-selected: rgba(51, 48, 44, 0.2);
      }

      /* ── Dark Mode (Cool Greige) ── */
      .dark {
        --neutral-50: #1a1918;
        --neutral-100: #252320;
        --neutral-200: #353230;
        --neutral-300: #454240;
        --neutral-400: #605c58;
        --neutral-500: #807a74;
        --neutral-600: #a09890;
        --neutral-700: #b8b1a8;
        --neutral-800: #d8d3cd;
        --neutral-900: #f0eeeb;

        --primary-50: #2a2725;
        --primary-100: #3a3530;
        --primary-200: #504840;
        --primary-300: #685e55;
        --primary-400: #8d7b6a;
        --primary-500: #a89888;
        --primary-600: #c0afa0;
        --primary-700: #d0c2b5;
        --primary-800: #e0d8d0;
        --primary-900: #f0ebe5;

        --surface: #222120;
        --surface-hover: #2a2826;
        --on-primary: #1a1918;
        --on-toast: #1a1918;
        --overlay: rgba(0, 0, 0, 0.7);
        --danger: #ef4444;
        --danger-light: #3b1c1c;
        --danger-hover: #dc2626;
        --neutral-50-alpha: rgba(26, 25, 24, 0.5);
        --ring-selected: rgba(240, 238, 235, 0.2);
      }

      body {
        font-family: "Inter", sans-serif;
        transition:
          background-color 0.3s,
          color 0.3s;
      }
      .calendar-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
      }
      .day-cell {
        min-height: 100px;
        transition: all 0.2s;
        border-right: 1px solid var(--neutral-100);
        border-bottom: 1px solid var(--neutral-100);
      }
      .dark .day-cell {
        border-right-color: var(--neutral-200);
        border-bottom-color: var(--neutral-200);
      }
      .dark .calendar-grid.border-neutral-100 {
        border-color: var(--neutral-200) !important;
      }
      .day-cell:hover {
        background-color: var(--surface-hover);
      }
      .slot-badge {
        font-size: 0.7rem;
        padding: 2px 4px;
        border-radius: 4px;
        margin-top: 4px;
        display: block;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .color-tooltip {
        position: absolute;
        bottom: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--neutral-900);
        color: var(--neutral-50);
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 11px;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s;
        z-index: 100;
      }
      .color-tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 4px solid transparent;
        border-top-color: var(--neutral-900);
      }
      .color-picker-wrapper:hover .color-tooltip {
        opacity: 1;
      }
    </style>
  </head>
  <body class="bg-neutral-50 text-neutral-800 min-h-screen pb-12">
    <!-- Header -->
    <header
      class="bg-surface border-b border-neutral-200 px-6 py-4 sticky top-0 z-50"
    >
      <div
        class="max-w-6xl mx-auto flex flex-col md:flex-row justify-between items-center gap-4"
      >
        <div class="flex items-center gap-2">
          <div class="bg-primary-600 p-2 rounded-lg">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6 text-on-primary"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
              />
            </svg>
          </div>
          <h1 class="text-xl font-bold text-neutral-800">WorkSlots</h1>
        </div>

        <div class="flex items-center gap-3">
          <button
            id="authBtn"
            onclick="handleAuthClick()"
            disabled
            class="flex items-center gap-2 px-4 py-2 border border-neutral-300 rounded-lg hover:bg-neutral-50 font-medium transition-all text-sm disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <img
              src="https://www.gstatic.com/images/branding/product/1x/g_suite_2020q4_48dp.png"
              class="w-4 h-4"
              alt="G"
            />
            <span>Connect Google</span>
          </button>
          <button
            id="signOutBtn"
            onclick="handleSignoutClick()"
            class="hidden px-4 py-2 text-sm text-danger hover:bg-danger-light rounded-lg"
          >
            Sign Out
          </button>
          <button
            onclick="openSyncConfirmModal()"
            id="syncBtn"
            class="bg-primary-600 text-on-primary px-5 py-2 rounded-lg hover:bg-primary-700 font-semibold shadow-sm transition-all text-sm disabled:opacity-50 disabled:cursor-not-allowed"
            disabled
          >
            Sync Current Month
          </button>
          <button
            onclick="toggleTheme()"
            id="themeToggle"
            class="p-2 rounded-lg border border-neutral-200 hover:bg-neutral-100 transition-all text-neutral-600"
            title="Toggle dark mode"
          >
            <svg
              id="themeIconSun"
              xmlns="http://www.w3.org/2000/svg"
              class="h-5 w-5 hidden"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
              />
            </svg>
            <svg
              id="themeIconMoon"
              xmlns="http://www.w3.org/2000/svg"
              class="h-5 w-5"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
              />
            </svg>
          </button>
        </div>
      </div>
    </header>

    <main
      class="max-w-6xl mx-auto mt-8 px-4 grid grid-cols-1 lg:grid-cols-4 lg:grid-rows-[min-content_1fr] gap-8"
    >
      <!-- Sidebar: Slot Definitions -->
      <div class="lg:col-span-1 space-y-6">
        <div
          class="bg-surface p-6 rounded-xl shadow-sm border border-neutral-200"
        >
          <h2
            class="text-sm font-bold text-neutral-500 uppercase tracking-wider mb-4"
          >
            Your Slot Types
          </h2>
          <div id="slotTypeList" class="space-y-3 mb-6">
            <!-- Slot Items injected here -->
          </div>
          <button
            id="addSlotTypeBtn"
            onclick="addNewSlotType()"
            class="w-full py-2 border-2 border-dashed border-neutral-200 rounded-lg text-neutral-400 hover:text-primary-600 hover:border-primary-300 transition-all text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:text-neutral-400 disabled:hover:border-neutral-200"
            disabled
          >
            + Add New Slot Type
          </button>
        </div>
      </div>

      <!-- Main Content: Calendar -->
      <div class="lg:col-span-3 lg:row-span-2">
        <div
          class="bg-surface rounded-xl shadow-sm border border-neutral-200 overflow-hidden"
        >
          <div
            class="p-6 border-b border-neutral-100 flex justify-between items-center"
          >
            <h2
              id="currentMonthDisplay"
              class="text-lg font-bold text-neutral-800"
            >
              January 2024
            </h2>
            <div class="flex gap-2">
              <button
                id="refreshBtn"
                onclick="loadSlotsFromCalendar()"
                class="p-2 hover:bg-neutral-100 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hidden"
                title="Reload slots from Google Calendar"
                disabled
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z"
                    clip-rule="evenodd"
                  />
                </svg>
              </button>
              <button
                onclick="changeMonth(-1)"
                class="p-2 hover:bg-neutral-100 rounded-lg"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                    clip-rule="evenodd"
                  />
                </svg>
              </button>
              <button
                onclick="changeMonth(1)"
                class="p-2 hover:bg-neutral-100 rounded-lg"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                    clip-rule="evenodd"
                  />
                </svg>
              </button>
            </div>
          </div>

          <div class="calendar-grid bg-neutral-50 border-b border-neutral-100">
            <div
              class="text-center py-2 text-xs font-bold text-neutral-400 uppercase"
            >
              Sun
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-neutral-400 uppercase"
            >
              Mon
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-neutral-400 uppercase"
            >
              Tue
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-neutral-400 uppercase"
            >
              Wed
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-neutral-400 uppercase"
            >
              Thu
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-neutral-400 uppercase"
            >
              Fri
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-neutral-400 uppercase"
            >
              Sat
            </div>
          </div>

          <div id="calendarGrid" class="calendar-grid">
            <!-- JS Injected Cells -->
          </div>
        </div>
      </div>

      <!-- Instructions (below calendar on small screens, in sidebar column on large) -->
      <div class="lg:col-span-1">
        <div class="bg-primary-50 p-4 rounded-xl border border-primary-100">
          <h3 class="text-xs font-bold text-primary-800 uppercase mb-2">
            Instructions
          </h3>
          <p class="text-xs text-primary-700 leading-relaxed">
            1. Log in with your Google account.<br />
            2. Define your slots.<br />
            3. Click a date to assign a slot.<br />
            4. Navigate to the month you want to sync.<br />
            5. Click "Sync Current Month" to update your Google Calendar.
          </p>
        </div>
      </div>
    </main>

    <!-- Footer -->
    <footer
      class="max-w-6xl mx-auto mt-12 mb-8 px-4 text-center text-xs text-neutral-400 space-x-3"
    >
      <a
        href="privacy-policy.html"
        class="hover:text-primary-600 transition-colors"
        >Privacy Policy</a
      >
      <span>·</span>
      <a
        href="terms-of-service.html"
        class="hover:text-primary-600 transition-colors"
        >Terms of Service</a
      >
    </footer>

    <!-- Modal for Assigning Slots -->
    <div
      id="assignModal"
      class="hidden fixed inset-0 bg-overlay flex items-center justify-center z-[100] px-4"
    >
      <div class="bg-surface rounded-2xl shadow-2xl p-6 max-w-sm w-full">
        <h3 class="text-lg font-bold mb-4" id="modalTitle">Select Slot</h3>
        <div id="modalSlotOptions" class="space-y-2"></div>
        <div class="mt-6 flex justify-end gap-3">
          <button
            onclick="closeModal()"
            class="px-4 py-2 text-sm text-neutral-600 hover:bg-neutral-100 rounded-lg"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Sync Confirmation Modal -->
    <div
      id="syncConfirmModal"
      class="hidden fixed inset-0 bg-overlay flex items-center justify-center z-[100] px-4"
    >
      <div class="bg-surface rounded-2xl shadow-2xl p-6 max-w-sm w-full">
        <h3 class="text-lg font-bold mb-2 text-neutral-800">Confirm Sync</h3>
        <p class="text-sm text-neutral-600 mb-6">
          Are you sure you want to sync the current month to your Google
          Calendar? This will update existing events and create new ones as
          needed.
        </p>
        <div class="flex justify-end gap-3">
          <button
            onclick="closeSyncConfirmModal()"
            class="px-4 py-2 text-sm text-neutral-600 hover:bg-neutral-100 rounded-lg"
          >
            Cancel
          </button>
          <button
            onclick="confirmSync()"
            class="px-4 py-2 text-sm text-on-primary bg-primary-600 hover:bg-primary-700 rounded-lg font-semibold shadow-sm transition-all"
          >
            Yes, Sync
          </button>
        </div>
      </div>
    </div>

    <!-- Notification Toast -->
    <div
      id="toast"
      class="fixed bottom-6 right-6 translate-y-20 opacity-0 transition-all duration-300 bg-neutral-900 text-on-toast px-6 py-3 rounded-xl shadow-xl flex items-center gap-3 z-[1000]"
    >
      <span id="toastMessage">Syncing...</span>
    </div>

    <script>
      // ── Theme (dark mode) ──
      function initTheme() {
        const saved = localStorage.getItem("theme");
        const prefersDark = window.matchMedia(
          "(prefers-color-scheme: dark)",
        ).matches;
        if (saved === "dark" || (!saved && prefersDark)) {
          document.documentElement.classList.add("dark");
        }
        updateThemeIcon();
      }

      function toggleTheme() {
        document.documentElement.classList.toggle("dark");
        const isDark = document.documentElement.classList.contains("dark");
        localStorage.setItem("theme", isDark ? "dark" : "light");
        updateThemeIcon();
      }

      function updateThemeIcon() {
        const isDark = document.documentElement.classList.contains("dark");
        document
          .getElementById("themeIconSun")
          .classList.toggle("hidden", !isDark);
        document
          .getElementById("themeIconMoon")
          .classList.toggle("hidden", isDark);
      }

      initTheme();

      // Dev mode: add ?dev to URL to simulate login with mock data for UI testing
      const isDevMode = new URLSearchParams(window.location.search).has("dev");

      // Provide minimal gapi/google mocks so the app doesn't crash in dev mode.
      // Always force-override gapi.client because even if the CDN script loads,
      // gapi.client won't exist until gapi.load("client") is called, which we
      // skip in dev mode.
      if (isDevMode) {
        window.gapi = window.gapi || {};
        gapi.client = {
          _token: null,
          getToken() {
            return this._token;
          },
          setToken(t) {
            this._token = t || null;
          },
          init() {
            return Promise.resolve();
          },
        };
        gapi.load = gapi.load || function () {};

        window.google = window.google || {};
        google.accounts = google.accounts || {};
        google.accounts.oauth2 = {
          initTokenClient() {
            return {};
          },
          revoke() {},
        };
      }

      const CLIENT_ID =
        "215553097336-6bktnv96gllnk4u7e24u2tf14a1ji9pp.apps.googleusercontent.com";
      const API_KEY = "AIzaSyCuBcQEWDy5jIg4OyFl0zFiKZ1KYdTBBQk";
      const DISCOVERY_DOC =
        "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest";
      const SCOPES =
        "https://www.googleapis.com/auth/calendar.app.created";
      // Used to identify WorkSlots-managed events (make this hard-to-guess).
      const WORK_SLOTS_MANAGED_VALUE =
        "workslots_9f6c2a7d4b1e4c3aa0d8f7e2c1b9a6d5";
      const WORK_SLOTS_PRIVATE_FILTER = `workSlotsManaged=${WORK_SLOTS_MANAGED_VALUE}`;
      // Used to identify WorkSlots calendar in description (make this hard-to-guess).
      const WORK_SLOTS_CALENDAR_IDENTIFIER =
        "workslots_cal_8e7f3c9a2d1b5e4f6c8a0d3b7e2f1c9a";
      const WORK_SLOTS_CALENDAR_NAME = "WorkSlots";
      // Boundary markers for app-managed content in calendar description
      const WORK_SLOTS_DATA_START = "--- WORKSLOTS DATA START ---";
      const WORK_SLOTS_DATA_END = "--- WORKSLOTS DATA END ---";

      let tokenClient;
      let gapiInited = false;
      let gisInited = false;

      let currentYear = new Date().getFullYear();
      let currentMonth = new Date().getMonth();
      let selectedDate = null;
      let selectedCalendarId = null;
      let userCalendars = [];

      let slotTypes = [];

      let schedule = {}; // No longer stored in localStorage - loaded from Google Calendar
      let googleEventColors = null; // { [colorId]: { background, foreground } }

      function getSlotColorHex(slot) {
        if (
          slot?.colorId &&
          googleEventColors?.[String(slot.colorId)]?.background
        ) {
          return googleEventColors[String(slot.colorId)].background;
        }
        return slot?.color || "#6366f1";
      }

      function toggleSlotColorPicker(slotId) {
        if (!googleEventColors) return;
        closeAllSlotColorPickers(slotId);
        const menu = document.getElementById(`slotColorMenu_${slotId}`);
        if (!menu) return;
        const isHidden = menu.classList.contains("hidden");
        if (isHidden) menu.classList.remove("hidden");
        else menu.classList.add("hidden");
      }

      function closeAllSlotColorPickers(exceptSlotId = null) {
        document.querySelectorAll('[id^="slotColorMenu_"]').forEach((el) => {
          if (
            exceptSlotId !== null &&
            el.id === `slotColorMenu_${exceptSlotId}`
          ) {
            return;
          }
          el.classList.add("hidden");
        });
      }

      function setSlotColorId(slotId, colorId) {
        updateSlot(slotId, "colorId", String(colorId));
        closeAllSlotColorPickers();
      }

      function renderColorSwatches(slotId, selectedColorId) {
        if (!googleEventColors) {
          return "";
        }

        const ids = Object.keys(googleEventColors).sort(
          (a, b) => Number(a) - Number(b),
        );
        return ids
          .map((id) => {
            const color = googleEventColors[id]?.background || "#000000";
            const isSelected = String(selectedColorId) === String(id);
            return `
              <button
                type="button"
                class="w-6 h-6 rounded-full border ${
                  isSelected
                    ? "border-neutral-900 ring-2 ring-[var(--ring-selected)]"
                    : "border-neutral-200"
                } hover:border-neutral-500 focus:outline-none focus:ring-2 focus:ring-primary-300"
                style="background-color: ${color}"
                title="Color ${id}"
                onclick="setSlotColorId(${slotId}, '${id}')"
              ></button>
            `;
          })
          .join("");
      }

      async function findOrCreateWorkSlotsCalendar() {
        if (!gapi.client.getToken()) {
          throw new Error("Not authenticated");
        }

        try {
          // List all calendars
          const response = await gapi.client.calendar.calendarList.list();
          const calendars = response.result.items || [];

          // Look for calendar with identifier in description (check all calendars)
          for (const cal of calendars) {
            try {
              // Fetch full calendar details to check description
              const fullCal = await gapi.client.calendar.calendars.get({
                calendarId: cal.id,
              });

              // Check if description contains our identifier
              const description = fullCal.result.description || "";
              if (description.includes(WORK_SLOTS_CALENDAR_IDENTIFIER)) {
                selectedCalendarId = cal.id;
                showToast("Using WorkSlots calendar");
                return cal.id;
              }
            } catch (err) {
              console.warn(`Could not fetch calendar ${cal.id} details:`, err);
              continue;
            }
          }

          // Not found - create a new calendar with identifier and boundary markers in description
          const initialDescription = `${WORK_SLOTS_DATA_START}\nWorkSlots Calendar - ID: ${WORK_SLOTS_CALENDAR_IDENTIFIER}\nSLOT_TYPES_JSON: []\n${WORK_SLOTS_DATA_END}`;
          const newCalendar = await gapi.client.calendar.calendars.insert({
            resource: {
              summary: WORK_SLOTS_CALENDAR_NAME,
              description: initialDescription,
            },
          });

          selectedCalendarId = newCalendar.result.id;
          showToast("Created WorkSlots calendar");
          return newCalendar.result.id;
        } catch (err) {
          console.error("Error finding/creating WorkSlots calendar:", err);
          throw err;
        }
      }

      async function loadSlotTypesFromCalendar(calendarId) {
        if (!calendarId) return null;

        try {
          const response = await gapi.client.calendar.calendars.get({
            calendarId: calendarId,
          });

          // Look for slot types within the boundary markers
          const description = response.result.description || "";
          const startIdx = description.indexOf(WORK_SLOTS_DATA_START);
          const endIdx = description.indexOf(WORK_SLOTS_DATA_END);

          if (startIdx === -1 || endIdx === -1 || startIdx >= endIdx) {
            return null;
          }

          // Extract content between boundaries
          const dataSection = description
            .substring(startIdx + WORK_SLOTS_DATA_START.length, endIdx)
            .trim();
          const slotTypesMatch = dataSection.match(
            /SLOT_TYPES_JSON:\s*(\[.*\]|\{.*\})/s,
          );

          if (slotTypesMatch) {
            try {
              const parsed = JSON.parse(slotTypesMatch[1]);
              return Array.isArray(parsed) ? parsed : null;
            } catch (parseErr) {
              console.error(
                "Error parsing slot types from description:",
                parseErr,
              );
              return null;
            }
          }

          return null;
        } catch (err) {
          console.error("Error loading slot types from calendar:", err);
          return null;
        }
      }

      async function saveSlotTypesToCalendar(calendarId, slotTypes) {
        if (!calendarId) {
          console.warn("No calendar ID provided for saving slot types");
          return false;
        }

        try {
          // Get current calendar to preserve user content outside boundaries
          const currentCal = await gapi.client.calendar.calendars.get({
            calendarId: calendarId,
          });

          const currentDesc = currentCal.result.description || "";

          // Extract user content before and after the boundary
          const startIdx = currentDesc.indexOf(WORK_SLOTS_DATA_START);
          const endIdx = currentDesc.indexOf(WORK_SLOTS_DATA_END);

          let beforeBoundary = "";
          let afterBoundary = "";

          if (startIdx !== -1 && endIdx !== -1 && startIdx < endIdx) {
            // Boundaries exist - extract user content
            beforeBoundary = currentDesc.substring(0, startIdx).trim();
            afterBoundary = currentDesc
              .substring(endIdx + WORK_SLOTS_DATA_END.length)
              .trim();
          } else {
            // No boundaries yet - check if there's existing content
            // If description contains the identifier, use everything before it as user content
            if (currentDesc.includes(WORK_SLOTS_CALENDAR_IDENTIFIER)) {
              const identifierIdx = currentDesc.indexOf(
                WORK_SLOTS_CALENDAR_IDENTIFIER,
              );
              beforeBoundary = currentDesc.substring(0, identifierIdx).trim();
              // Remove any old format data after identifier
              const afterIdentifier = currentDesc.substring(identifierIdx);
              const oldDataMatch =
                afterIdentifier.match(/SLOT_TYPES_JSON:.*$/s);
              if (oldDataMatch) {
                const oldDataEnd =
                  identifierIdx +
                  afterIdentifier.indexOf(oldDataMatch[0]) +
                  oldDataMatch[0].length;
                afterBoundary = currentDesc.substring(oldDataEnd).trim();
              }
            } else {
              // No identifier - preserve all existing content as user content
              beforeBoundary = currentDesc.trim();
            }
          }

          // Build new description with boundaries
          // Identifier is now inside the boundary section
          const dataSection = `WorkSlots Calendar - ID: ${WORK_SLOTS_CALENDAR_IDENTIFIER}\nSLOT_TYPES_JSON: ${JSON.stringify(slotTypes)}`;

          const parts = [];

          // Add user content before boundary
          if (beforeBoundary) {
            parts.push(beforeBoundary);
          }

          // Add app-managed section with boundaries (identifier is inside)
          parts.push(WORK_SLOTS_DATA_START);
          parts.push(dataSection);
          parts.push(WORK_SLOTS_DATA_END);

          // Add user content after boundary
          if (afterBoundary) {
            parts.push(afterBoundary);
          }

          const newDescription = parts.join("\n\n");

          await gapi.client.calendar.calendars.patch({
            calendarId: calendarId,
            resource: {
              description: newDescription,
            },
          });
          return true;
        } catch (err) {
          console.error("Error saving slot types to calendar:", err);
          showToast("Error saving slot types. Check console.");
          return false;
        }
      }

      function renderCalendar() {
        const grid = document.getElementById("calendarGrid");
        const display = document.getElementById("currentMonthDisplay");
        grid.innerHTML = "";

        const firstDay = new Date(currentYear, currentMonth, 1).getDay();
        const daysInMonth = new Date(
          currentYear,
          currentMonth + 1,
          0,
        ).getDate();

        const monthNames = [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
        ];
        display.innerText = `${monthNames[currentMonth]} ${currentYear}`;

        for (let i = 0; i < firstDay; i++) {
          const cell = document.createElement("div");
          cell.className = "day-cell bg-[var(--neutral-50-alpha)]";
          grid.appendChild(cell);
        }

        for (let d = 1; d <= daysInMonth; d++) {
          const dateKey = `${currentYear}-${String(currentMonth + 1).padStart(2, "0")}-${String(d).padStart(2, "0")}`;
          const cell = document.createElement("div");
          cell.className = "day-cell p-2 cursor-pointer";
          cell.onclick = () => openAssignModal(dateKey, d);

          const dayNum = document.createElement("span");
          dayNum.className = "text-sm font-medium text-neutral-500";
          dayNum.innerText = d;

          cell.appendChild(dayNum);

          if (schedule[dateKey]) {
            const slot = slotTypes.find((s) => s.id == schedule[dateKey]);
            if (slot) {
              const badge = document.createElement("div");
              badge.className = "slot-badge text-on-primary";
              badge.style.backgroundColor = getSlotColorHex(slot);
              badge.innerText = `${slot.name} (${slot.start})`;
              cell.appendChild(badge);
            }
          }
          grid.appendChild(cell);
        }
      }

      function changeMonth(delta) {
        currentMonth += delta;
        if (currentMonth > 11) {
          currentMonth = 0;
          currentYear++;
        }
        if (currentMonth < 0) {
          currentMonth = 11;
          currentYear--;
        }
        renderCalendar();
        // Load slots from Google Calendar when month changes (if authenticated)
        if (gapi.client.getToken() && selectedCalendarId) {
          loadSlotsFromCalendar();
        }
      }

      function renderSlotTypes() {
        const list = document.getElementById("slotTypeList");
        list.innerHTML = "";
        slotTypes.forEach((slot) => {
          const div = document.createElement("div");
          div.className =
            "p-3 bg-neutral-50 rounded-lg border border-neutral-100 space-y-2";
          div.innerHTML = `
                    <div class="flex justify-between items-center">
                        <input type="text" value="${slot.name}" onchange="updateSlot(${slot.id}, 'name', this.value)" class="bg-transparent font-bold text-sm w-24 outline-none focus:text-primary-600">
                        <button onclick="removeSlotType(${slot.id})" class="text-neutral-400 hover:text-danger-hover">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                    <div class="flex items-center gap-2 text-xs text-neutral-500">
                        <input type="time" value="${slot.start}" onchange="updateSlot(${slot.id}, 'start', this.value)" class="bg-surface border rounded px-1">
                        <span>to</span>
                        <input type="time" value="${slot.end}" onchange="updateSlot(${slot.id}, 'end', this.value)" class="bg-surface border rounded px-1">
                    </div>
                    <div class="flex items-center gap-2 text-xs text-neutral-500">
                        <span class="font-medium">Color</span>
                        <div class="relative inline-block color-picker-wrapper" data-color-picker="true">
                          <button
                            type="button"
                            class="w-6 h-6 rounded-full border border-neutral-200 shadow-sm hover:border-neutral-400 focus:outline-none focus:ring-2 focus:ring-primary-300 disabled:opacity-50 disabled:cursor-not-allowed"
                            style="background-color: ${getSlotColorHex(slot)}"
                            onclick="toggleSlotColorPicker(${slot.id})"
                            ${googleEventColors ? "" : "disabled"}
                          ></button>
                          ${
                            !googleEventColors
                              ? `
                          <div class="color-tooltip">
                            Please log in to select colors
                          </div>
                          `
                              : ""
                          }
                          <div
                            id="slotColorMenu_${slot.id}"
                            class="hidden absolute top-full left-0 mt-1 p-2 bg-surface border border-neutral-200 rounded-xl shadow-xl z-50"
                            style="min-width: max-content;"
                          >
                            <div class="grid grid-cols-6 gap-2">
                              ${renderColorSwatches(slot.id, slot.colorId)}
                            </div>
                          </div>
                        </div>
                    </div>
                `;
          list.appendChild(div);
        });
      }

      async function addNewSlotType() {
        // Check if user is logged in
        if (!gapi.client.getToken()) {
          showToast("Please log in to create slot types");
          return;
        }

        // Check if calendar is available
        if (!selectedCalendarId) {
          showToast("Calendar not ready. Please try again.");
          return;
        }

        const id = Date.now();
        slotTypes.push({
          id,
          name: "New Slot",
          start: "09:00",
          end: "17:00",
          colorId: "1",
          color: "#6366f1",
        });
        renderSlotTypes();
        if (selectedCalendarId) {
          await saveSlotTypesToCalendar(selectedCalendarId, slotTypes);
        }
      }

      async function updateSlot(id, field, value) {
        const slot = slotTypes.find((s) => s.id === id);
        if (slot) {
          slot[field] = value;
          if (
            field === "colorId" &&
            googleEventColors?.[String(value)]?.background
          ) {
            // Keep legacy color updated for UI fallbacks.
            slot.color = googleEventColors[String(value)].background;
          }
        }
        renderSlotTypes();
        renderCalendar();
        if (selectedCalendarId) {
          await saveSlotTypesToCalendar(selectedCalendarId, slotTypes);
        }
      }

      async function removeSlotType(id) {
        slotTypes = slotTypes.filter((s) => s.id !== id);
        Object.keys(schedule).forEach((k) => {
          if (schedule[k] == id) delete schedule[k];
        });
        renderSlotTypes();
        renderCalendar();
        if (selectedCalendarId) {
          await saveSlotTypesToCalendar(selectedCalendarId, slotTypes);
        }
      }

      function openAssignModal(dateKey, dayNum) {
        // Check if user is authenticated first
        if (!gapi.client.getToken()) {
          showToast("Please log in first");
          return;
        }

        // Check if calendar is available
        if (!selectedCalendarId) {
          showToast("Calendar not ready. Please try again.");
          return;
        }

        selectedDate = dateKey;
        document.getElementById("modalTitle").innerText =
          `Assign Slot: ${dayNum} ${document.getElementById("currentMonthDisplay").innerText}`;
        const container = document.getElementById("modalSlotOptions");
        container.innerHTML = `<button onclick="assignSlot(null)" class="w-full text-left p-3 rounded-xl border border-neutral-200 hover:bg-neutral-50 text-sm font-medium transition-all">No Slot (Clear)</button>`;

        slotTypes.forEach((slot) => {
          const btn = document.createElement("button");
          btn.className =
            "w-full text-left p-3 rounded-xl border border-neutral-200 hover:border-primary-300 hover:bg-primary-50 text-sm font-medium transition-all flex justify-between items-center";
          btn.onclick = () => assignSlot(slot.id);
          btn.innerHTML = `<span>${slot.name} <span class="text-neutral-400 font-normal ml-2">${slot.start} - ${slot.end}</span></span><div class="w-3 h-3 rounded-full" style="background-color: ${getSlotColorHex(slot)}"></div>`;
          container.appendChild(btn);
        });
        document.getElementById("assignModal").classList.remove("hidden");
      }

      function closeModal() {
        document.getElementById("assignModal").classList.add("hidden");
      }

      function assignSlot(slotId) {
        if (slotId === null) delete schedule[selectedDate];
        else schedule[selectedDate] = slotId;
        // No longer storing in localStorage - schedule is only in memory until synced
        renderCalendar();
        closeModal();
      }

      function gapiLoaded() {
        gapi.load("client", initializeGapiClient);
      }

      async function initializeGapiClient() {
        await gapi.client.init({
          apiKey: API_KEY,
          discoveryDocs: [DISCOVERY_DOC],
        });
        gapiInited = true;
        checkBeforeStart();
      }

      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: "",
        });
        gisInited = true;
        checkBeforeStart();
      }

      function checkBeforeStart() {
        if (gapiInited && gisInited) {
          document.getElementById("authBtn").disabled = false;
        }
      }

      function handleAuthClick() {
        if (!gapiInited || !gisInited) {
          showToast("Still loading Google APIs, please wait...");
          return;
        }
        tokenClient.callback = async (resp) => {
          if (resp.error !== undefined) throw resp;
          document.getElementById("authBtn").classList.add("hidden");
          document.getElementById("signOutBtn").classList.remove("hidden");
          showToast("Connected to Google!");

          try {
            // Find or create WorkSlots calendar
            await findOrCreateWorkSlotsCalendar();

            // Load slot types from calendar
            const loadedSlotTypes =
              await loadSlotTypesFromCalendar(selectedCalendarId);
            if (loadedSlotTypes && loadedSlotTypes.length > 0) {
              slotTypes = loadedSlotTypes;
              renderSlotTypes();
            }

            // Load event colors for color picker
            await loadEventColors();

            // Enable UI
            document.getElementById("refreshBtn").classList.remove("hidden");
            document.getElementById("refreshBtn").disabled = false;
            document.getElementById("syncBtn").disabled = false;
            document.getElementById("addSlotTypeBtn").disabled = false;

            // Load existing slots from calendar
            await loadSlotsFromCalendar();
          } catch (err) {
            console.error("Error during authentication setup:", err);
            showToast("Error setting up calendar. Check console.");
          }
        };
        if (gapi.client.getToken() === null)
          tokenClient.requestAccessToken({ prompt: "consent" });
        else tokenClient.requestAccessToken({ prompt: "" });
      }

      function handleSignoutClick() {
        const token = gapi.client.getToken();
        if (token !== null) {
          google.accounts.oauth2.revoke(token.access_token);
          gapi.client.setToken("");
          document.getElementById("authBtn").classList.remove("hidden");
          document.getElementById("signOutBtn").classList.add("hidden");
          document.getElementById("refreshBtn").classList.add("hidden");
          document.getElementById("syncBtn").disabled = true;
          document.getElementById("addSlotTypeBtn").disabled = true;
          selectedCalendarId = null;
          schedule = {}; // Clear schedule on sign out
          slotTypes = []; // Clear slot types on sign out
          googleEventColors = null;
          renderCalendar();
          renderSlotTypes();
          showToast("Signed out.");
        }
      }

      // ── Dev mode: simulate login with mock data ──
      function handleDevLogin() {
        // Set a fake token so all gapi.client.getToken() checks pass
        gapi.client.setToken({ access_token: "dev-fake-token" });

        // Fake calendar ID
        selectedCalendarId = "dev-calendar";

        // Mock Google event colors (mirrors Google Calendar's 11 event colors)
        googleEventColors = {
          1: { background: "#a4bdfc", foreground: "#1d1d1d" },
          2: { background: "#7ae7bf", foreground: "#1d1d1d" },
          3: { background: "#dbadff", foreground: "#1d1d1d" },
          4: { background: "#ff887c", foreground: "#1d1d1d" },
          5: { background: "#fbd75b", foreground: "#1d1d1d" },
          6: { background: "#ffb878", foreground: "#1d1d1d" },
          7: { background: "#46d6db", foreground: "#1d1d1d" },
          8: { background: "#e1e1e1", foreground: "#1d1d1d" },
          9: { background: "#5484ed", foreground: "#1d1d1d" },
          10: { background: "#51b749", foreground: "#1d1d1d" },
          11: { background: "#dc2127", foreground: "#1d1d1d" },
        };

        // Mock slot types
        slotTypes = [
          {
            id: 1,
            name: "Deep Work",
            start: "09:00",
            end: "12:00",
            colorId: "9",
          },
          {
            id: 2,
            name: "Meetings",
            start: "13:00",
            end: "15:00",
            colorId: "4",
          },
          { id: 3, name: "Admin", start: "15:30", end: "17:00", colorId: "5" },
        ];

        // Populate a few sample schedule entries for the current month
        schedule = {};
        const daysInMonth = new Date(
          currentYear,
          currentMonth + 1,
          0,
        ).getDate();
        for (let d = 1; d <= daysInMonth; d++) {
          const dayOfWeek = new Date(currentYear, currentMonth, d).getDay();
          // Skip weekends
          if (dayOfWeek === 0 || dayOfWeek === 6) continue;
          const dateKey = `${currentYear}-${String(currentMonth + 1).padStart(2, "0")}-${String(d).padStart(2, "0")}`;
          // Rotate through slot types for variety
          if (d % 3 === 1)
            schedule[dateKey] = 1; // Deep Work
          else if (d % 3 === 2)
            schedule[dateKey] = 2; // Meetings
          else schedule[dateKey] = 3; // Admin
        }

        // Toggle UI to authenticated state
        document.getElementById("authBtn").classList.add("hidden");
        document.getElementById("signOutBtn").classList.remove("hidden");
        document.getElementById("refreshBtn").classList.remove("hidden");
        document.getElementById("refreshBtn").disabled = false;
        document.getElementById("syncBtn").disabled = false;
        document.getElementById("addSlotTypeBtn").disabled = false;

        // Re-render
        renderSlotTypes();
        renderCalendar();
        showToast("Dev mode: logged in with mock data");
      }

      async function loadEventColors() {
        if (!gapi.client.getToken()) return;
        try {
          const resp = await gapi.client.calendar.colors.get();
          googleEventColors = resp?.result?.event || null;
          renderSlotTypes();
          renderCalendar();
        } catch (err) {
          console.error("Error loading event colors:", err);
          googleEventColors = null;
          renderSlotTypes();
        }
      }

      async function loadSlotsFromCalendar() {
        if (!gapi.client.getToken()) {
          showToast("Please log in first");
          return;
        }

        if (!selectedCalendarId) {
          showToast("Please select a calendar first");
          return;
        }

        showToast("Loading slots from Google Calendar...");

        try {
          // Calculate the date range for the current month
          const firstDay = new Date(currentYear, currentMonth, 1);
          const lastDay = new Date(currentYear, currentMonth + 1, 0);

          // Set timeMin to start of first day and timeMax to end of last day
          const timeMin = new Date(
            currentYear,
            currentMonth,
            1,
            0,
            0,
            0,
          ).toISOString();
          const timeMax = new Date(
            currentYear,
            currentMonth,
            lastDay.getDate(),
            23,
            59,
            59,
          ).toISOString();

          // Fetch all events for the current month
          const response = await gapi.client.calendar.events.list({
            calendarId: selectedCalendarId,
            timeMin: timeMin,
            timeMax: timeMax,
            privateExtendedProperty: WORK_SLOTS_PRIVATE_FILTER,
            singleEvents: true,
            orderBy: "startTime",
          });

          const events = response.result.items || [];

          // Clear current month's schedule
          const monthPrefix = `${currentYear}-${String(currentMonth + 1).padStart(2, "0")}`;
          Object.keys(schedule).forEach((key) => {
            if (key.startsWith(monthPrefix)) {
              delete schedule[key];
            }
          });

          // Process each event and match to slot types
          for (const event of events) {
            // Verify it's a WorkSlots event (ONLY this flag)
            const isWorkSlotsEvent =
              event.extendedProperties?.private?.workSlotsManaged ===
              WORK_SLOTS_MANAGED_VALUE;
            if (!isWorkSlotsEvent || !event.summary) {
              continue;
            }

            // Summary is the slot name
            const slotName = event.summary.trim();

            // Find matching slot type by name
            const slot = slotTypes.find((s) => s.name === slotName);
            if (!slot) {
              console.warn(
                `Slot type "${slotName}" not found in local slot types`,
              );
              continue;
            }

            // Extract date from event start time
            const startDateTime = event.start.dateTime || event.start.date;
            if (!startDateTime) continue;

            const eventDate = new Date(startDateTime);
            const dateKey = `${eventDate.getFullYear()}-${String(eventDate.getMonth() + 1).padStart(2, "0")}-${String(eventDate.getDate()).padStart(2, "0")}`;

            // Only add if it's in the current month
            if (dateKey.startsWith(monthPrefix)) {
              schedule[dateKey] = slot.id;
            }
          }

          renderCalendar();
          showToast("Slots loaded from Google Calendar!");
        } catch (err) {
          console.error("Error loading slots:", err);
          showToast("Error loading slots. Check console.");
        }
      }

      function openSyncConfirmModal() {
        document.getElementById("syncConfirmModal").classList.remove("hidden");
      }

      function closeSyncConfirmModal() {
        document.getElementById("syncConfirmModal").classList.add("hidden");
      }

      function confirmSync() {
        closeSyncConfirmModal();
        syncToCalendar();
      }

      async function syncToCalendar() {
        if (!gapi.client.getToken()) {
          handleAuthClick();
          return;
        }

        if (!selectedCalendarId) {
          showToast("Calendar not ready. Please try again.");
          return;
        }

        showToast(`Syncing slots...`);

        try {
          const monthPrefix = `${currentYear}-${String(currentMonth + 1).padStart(2, "0")}`;
          const daysInMonth = new Date(
            currentYear,
            currentMonth + 1,
            0,
          ).getDate();

          // Fetch all WorkSlots-managed events in the month (single API call)
          const monthTimeMin = new Date(
            currentYear,
            currentMonth,
            1,
            0,
            0,
            0,
          ).toISOString();
          const monthTimeMax = new Date(
            currentYear,
            currentMonth,
            daysInMonth,
            23,
            59,
            59,
          ).toISOString();

          const monthEventsResp = await gapi.client.calendar.events.list({
            calendarId: selectedCalendarId,
            timeMin: monthTimeMin,
            timeMax: monthTimeMax,
            privateExtendedProperty: WORK_SLOTS_PRIVATE_FILTER,
            singleEvents: true,
            orderBy: "startTime",
          });

          const monthEvents = monthEventsResp.result.items || [];

          // Group managed events by day (YYYY-MM-DD)
          const existingByDateKey = {};
          for (const event of monthEvents) {
            const isWorkSlotsEvent =
              event.extendedProperties?.private?.workSlotsManaged ===
              WORK_SLOTS_MANAGED_VALUE;
            if (!isWorkSlotsEvent) continue;

            const startDateTime = event.start?.dateTime || event.start?.date;
            if (!startDateTime) continue;

            const eventDate = new Date(startDateTime);
            const dateKey = `${eventDate.getFullYear()}-${String(eventDate.getMonth() + 1).padStart(2, "0")}-${String(eventDate.getDate()).padStart(2, "0")}`;
            if (!dateKey.startsWith(monthPrefix)) continue;

            if (!existingByDateKey[dateKey]) existingByDateKey[dateKey] = [];
            existingByDateKey[dateKey].push(event);
          }

          // For each day of the month:
          // - If schedule has no slot: delete managed event(s) for that day (Clear behavior)
          // - If schedule has slot: delete managed event(s) then insert the selected slot
          for (let d = 1; d <= daysInMonth; d++) {
            const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, "0")}-${String(d).padStart(2, "0")}`;

            const existing = existingByDateKey[dateStr] || [];
            for (const event of existing) {
              await gapi.client.calendar.events.delete({
                calendarId: selectedCalendarId,
                eventId: event.id,
              });
            }

            const slotId = schedule[dateStr];
            if (!slotId) {
              continue;
            }

            const slot = slotTypes.find((s) => s.id == slotId);
            if (!slot) continue;

            let startDate = new Date(dateStr + "T" + slot.start);
            let endDate = new Date(dateStr + "T" + slot.end);
            if (endDate <= startDate) endDate.setDate(endDate.getDate() + 1);

            const newEvent = {
              summary: `${slot.name}`,
              description: "Created via WorkSlots",
              ...(slot.colorId ? { colorId: String(slot.colorId) } : {}),
              start: {
                dateTime: startDate.toISOString(),
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
              },
              end: {
                dateTime: endDate.toISOString(),
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
              },
              extendedProperties: {
                private: {
                  workSlotsManaged: WORK_SLOTS_MANAGED_VALUE,
                },
              },
            };

            await gapi.client.calendar.events.insert({
              calendarId: selectedCalendarId,
              resource: newEvent,
            });
          }
          showToast("Month synced and updated!");
          // Reload slots from calendar to ensure display is accurate
          await loadSlotsFromCalendar();
        } catch (err) {
          console.error(err);
          showToast("Error syncing. Check console.");
        }
      }

      function showToast(msg) {
        const toast = document.getElementById("toast");
        document.getElementById("toastMessage").innerText = msg;
        toast.classList.remove("translate-y-20", "opacity-0");
        setTimeout(
          () => toast.classList.add("translate-y-20", "opacity-0"),
          3000,
        );
      }

      window.onload = () => {
        renderSlotTypes();
        renderCalendar();

        // In dev mode, replace the auth button with a "Dev Login" button
        // and skip Google API initialization entirely.
        if (isDevMode) {
          const authBtn = document.getElementById("authBtn");
          authBtn.disabled = false;
          authBtn.onclick = handleDevLogin;
          authBtn.innerHTML = `<span>&#9881; Dev Login</span>`;
        } else {
          gapiLoaded();
          gisLoaded();
        }

        document.addEventListener("click", (e) => {
          if (!e.target.closest('[data-color-picker="true"]')) {
            closeAllSlotColorPickers();
          }
        });

        // Check if user was previously authenticated and setup calendar
        // This will be called after gapi initializes if token exists
        // Skip in dev mode since there is no real token to restore.
        if (!isDevMode) {
          setTimeout(async () => {
            if (gapi.client && gapi.client.getToken()) {
              try {
                // Find or create WorkSlots calendar
                await findOrCreateWorkSlotsCalendar();

                // Load slot types from calendar
                const loadedSlotTypes =
                  await loadSlotTypesFromCalendar(selectedCalendarId);
                if (loadedSlotTypes && loadedSlotTypes.length > 0) {
                  slotTypes = loadedSlotTypes;
                  renderSlotTypes();
                }

                // Load event colors
                await loadEventColors();

                // Enable UI
                document
                  .getElementById("refreshBtn")
                  .classList.remove("hidden");
                document.getElementById("refreshBtn").disabled = false;
                document.getElementById("syncBtn").disabled = false;
                document.getElementById("addSlotTypeBtn").disabled = false;
                document.getElementById("authBtn").classList.add("hidden");
                document
                  .getElementById("signOutBtn")
                  .classList.remove("hidden");

                // Load existing slots from calendar
                await loadSlotsFromCalendar();
              } catch (err) {
                console.error("Error loading on page init:", err);
              }
            }
          }, 1000);
        }
      };
    </script>
  </body>
</html>
