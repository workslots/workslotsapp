<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WorkSlots</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap");
      body {
        font-family: "Inter", sans-serif;
      }
      .calendar-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
      }
      .day-cell {
        min-height: 100px;
        transition: all 0.2s;
        border-right: 1px solid #f1f5f9;
        border-bottom: 1px solid #f1f5f9;
      }
      .day-cell:hover {
        background-color: #f8fafc;
      }
      .slot-badge {
        font-size: 0.7rem;
        padding: 2px 4px;
        border-radius: 4px;
        margin-top: 4px;
        display: block;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .color-tooltip {
        position: absolute;
        bottom: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%);
        background-color: #1e293b;
        color: white;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 11px;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s;
        z-index: 100;
      }
      .color-tooltip::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        border: 4px solid transparent;
        border-top-color: #1e293b;
      }
      .color-picker-wrapper:hover .color-tooltip {
        opacity: 1;
      }
    </style>
  </head>
  <body class="bg-slate-50 min-h-screen pb-12">
    <!-- Header -->
    <header
      class="bg-white border-b border-slate-200 px-6 py-4 sticky top-0 z-50"
    >
      <div
        class="max-w-6xl mx-auto flex flex-col md:flex-row justify-between items-center gap-4"
      >
        <div class="flex items-center gap-2">
          <div class="bg-indigo-600 p-2 rounded-lg">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-6 w-6 text-white"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"
              />
            </svg>
          </div>
          <h1 class="text-xl font-bold text-slate-800">WorkSlots</h1>
        </div>

        <div class="flex items-center gap-3">
          <button
            id="authBtn"
            onclick="handleAuthClick()"
            class="flex items-center gap-2 px-4 py-2 border border-slate-300 rounded-lg hover:bg-slate-50 font-medium transition-all text-sm"
          >
            <img
              src="https://www.gstatic.com/images/branding/product/1x/g_suite_2020q4_48dp.png"
              class="w-4 h-4"
              alt="G"
            />
            <span>Connect Google</span>
          </button>
          <button
            id="signOutBtn"
            onclick="handleSignoutClick()"
            class="hidden px-4 py-2 text-sm text-red-600 hover:bg-red-50 rounded-lg"
          >
            Sign Out
          </button>
          <button
            onclick="syncToCalendar()"
            id="syncBtn"
            class="bg-indigo-600 text-white px-5 py-2 rounded-lg hover:bg-indigo-700 font-semibold shadow-sm transition-all text-sm disabled:opacity-50 disabled:cursor-not-allowed"
            disabled
          >
            Sync Current Month
          </button>
        </div>
      </div>
    </header>

    <main
      class="max-w-6xl mx-auto mt-8 px-4 grid grid-cols-1 lg:grid-cols-4 gap-8"
    >
      <!-- Sidebar: Slot Definitions -->
      <div class="lg:col-span-1 space-y-6">
        <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200">
          <h2
            class="text-sm font-bold text-slate-500 uppercase tracking-wider mb-4"
          >
            Your Slot Types
          </h2>
          <div id="slotTypeList" class="space-y-3 mb-6">
            <!-- Slot Items injected here -->
          </div>
          <button
            id="addSlotTypeBtn"
            onclick="addNewSlotType()"
            class="w-full py-2 border-2 border-dashed border-slate-200 rounded-lg text-slate-400 hover:text-indigo-600 hover:border-indigo-300 transition-all text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:text-slate-400 disabled:hover:border-slate-200"
            disabled
          >
            + Add New Slot Type
          </button>
        </div>

        <div class="bg-indigo-50 p-4 rounded-xl border border-indigo-100">
          <h3 class="text-xs font-bold text-indigo-800 uppercase mb-2">
            Instructions
          </h3>
          <p class="text-xs text-indigo-700 leading-relaxed">
            1. Define your slots.<br />
            2. Click a date to assign a slot.<br />
            3. Navigate to the month you want to sync.<br />
            4. Click "Sync Current Month" to update your Google Calendar.
          </p>
          <div class="mt-4 pt-4 border-t border-indigo-200">
            <h3 class="text-xs font-bold text-indigo-800 uppercase mb-1">
              Security Note
            </h3>
            <p class="text-[10px] text-indigo-700 leading-tight italic">
              If hosting on GitHub, ensure you've added your URL to "Authorized
              JavaScript Origins" in Google Console to prevent unauthorized use
              of your Client ID.
            </p>
          </div>
        </div>
      </div>

      <!-- Main Content: Calendar -->
      <div class="lg:col-span-3">
        <div
          class="bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden"
        >
          <div
            class="p-6 border-b border-slate-100 flex justify-between items-center"
          >
            <h2
              id="currentMonthDisplay"
              class="text-lg font-bold text-slate-800"
            >
              January 2024
            </h2>
            <div class="flex gap-2">
              <button
                id="refreshBtn"
                onclick="loadSlotsFromCalendar()"
                class="p-2 hover:bg-slate-100 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed hidden"
                title="Reload slots from Google Calendar"
                disabled
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z"
                    clip-rule="evenodd"
                  />
                </svg>
              </button>
              <button
                onclick="changeMonth(-1)"
                class="p-2 hover:bg-slate-100 rounded-lg"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                    clip-rule="evenodd"
                  />
                </svg>
              </button>
              <button
                onclick="changeMonth(1)"
                class="p-2 hover:bg-slate-100 rounded-lg"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"
                    clip-rule="evenodd"
                  />
                </svg>
              </button>
            </div>
          </div>

          <div class="calendar-grid bg-slate-50 border-b border-slate-100">
            <div
              class="text-center py-2 text-xs font-bold text-slate-400 uppercase"
            >
              Sun
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-slate-400 uppercase"
            >
              Mon
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-slate-400 uppercase"
            >
              Tue
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-slate-400 uppercase"
            >
              Wed
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-slate-400 uppercase"
            >
              Thu
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-slate-400 uppercase"
            >
              Fri
            </div>
            <div
              class="text-center py-2 text-xs font-bold text-slate-400 uppercase"
            >
              Sat
            </div>
          </div>

          <div id="calendarGrid" class="calendar-grid">
            <!-- JS Injected Cells -->
          </div>
        </div>
      </div>
    </main>

    <!-- Modal for Assigning Slots -->
    <div
      id="assignModal"
      class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100] px-4"
    >
      <div class="bg-white rounded-2xl shadow-2xl p-6 max-w-sm w-full">
        <h3 class="text-lg font-bold mb-4" id="modalTitle">Select Slot</h3>
        <div id="modalSlotOptions" class="space-y-2"></div>
        <div class="mt-6 flex justify-end gap-3">
          <button
            onclick="closeModal()"
            class="px-4 py-2 text-sm text-slate-600 hover:bg-slate-100 rounded-lg"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Notification Toast -->
    <div
      id="toast"
      class="fixed bottom-6 right-6 translate-y-20 opacity-0 transition-all duration-300 bg-slate-900 text-white px-6 py-3 rounded-xl shadow-xl flex items-center gap-3 z-[1000]"
    >
      <span id="toastMessage">Syncing...</span>
    </div>

    <script>
       const CLIENT_ID =
        "276844562286-biq705124253b75ro3fgj2o0garfci2v.apps.googleusercontent.com";
      const API_KEY = "AIzaSyCnDviyu5RBWmZfaY7c7bIvtkcTwet_X04";
      const DISCOVERY_DOC =
        "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest";
      const SCOPES =
        "https://www.googleapis.com/auth/calendar.events https://www.googleapis.com/auth/calendar";
      // Used to identify WorkSlots-managed events (make this hard-to-guess).
      const WORK_SLOTS_MANAGED_VALUE =
        "workslots_9f6c2a7d4b1e4c3aa0d8f7e2c1b9a6d5";
      const WORK_SLOTS_PRIVATE_FILTER = `workSlotsManaged=${WORK_SLOTS_MANAGED_VALUE}`;
      // Used to identify WorkSlots calendar in description (make this hard-to-guess).
      const WORK_SLOTS_CALENDAR_IDENTIFIER =
        "workslots_cal_8e7f3c9a2d1b5e4f6c8a0d3b7e2f1c9a";
      const WORK_SLOTS_CALENDAR_NAME = "WorkSlots";
      // Boundary markers for app-managed content in calendar description
      const WORK_SLOTS_DATA_START = "--- WORKSLOTS DATA START ---";
      const WORK_SLOTS_DATA_END = "--- WORKSLOTS DATA END ---";

      let tokenClient;
      let gapiInited = false;
      let gisInited = false;

      let currentYear = new Date().getFullYear();
      let currentMonth = new Date().getMonth();
      let selectedDate = null;
      let selectedCalendarId = null;
      let userCalendars = [];

      let slotTypes = [];

      let schedule = {}; // No longer stored in localStorage - loaded from Google Calendar
      let googleEventColors = null; // { [colorId]: { background, foreground } }

      function getSlotColorHex(slot) {
        if (
          slot?.colorId &&
          googleEventColors?.[String(slot.colorId)]?.background
        ) {
          return googleEventColors[String(slot.colorId)].background;
        }
        return slot?.color || "#6366f1";
      }

      function toggleSlotColorPicker(slotId) {
        if (!googleEventColors) return;
        closeAllSlotColorPickers(slotId);
        const menu = document.getElementById(`slotColorMenu_${slotId}`);
        if (!menu) return;
        const isHidden = menu.classList.contains("hidden");
        if (isHidden) menu.classList.remove("hidden");
        else menu.classList.add("hidden");
      }

      function closeAllSlotColorPickers(exceptSlotId = null) {
        document.querySelectorAll('[id^="slotColorMenu_"]').forEach((el) => {
          if (
            exceptSlotId !== null &&
            el.id === `slotColorMenu_${exceptSlotId}`
          ) {
            return;
          }
          el.classList.add("hidden");
        });
      }

      function setSlotColorId(slotId, colorId) {
        updateSlot(slotId, "colorId", String(colorId));
        closeAllSlotColorPickers();
      }

      function renderColorSwatches(slotId, selectedColorId) {
        if (!googleEventColors) {
          return "";
        }

        const ids = Object.keys(googleEventColors).sort(
          (a, b) => Number(a) - Number(b),
        );
        return ids
          .map((id) => {
            const color = googleEventColors[id]?.background || "#000000";
            const isSelected = String(selectedColorId) === String(id);
            return `
              <button
                type="button"
                class="w-6 h-6 rounded-full border ${
                  isSelected
                    ? "border-slate-900 ring-2 ring-slate-900/20"
                    : "border-slate-200"
                } hover:border-slate-500 focus:outline-none focus:ring-2 focus:ring-indigo-300"
                style="background-color: ${color}"
                title="Color ${id}"
                onclick="setSlotColorId(${slotId}, '${id}')"
              ></button>
            `;
          })
          .join("");
      }

      async function findOrCreateWorkSlotsCalendar() {
        if (!gapi.client.getToken()) {
          throw new Error("Not authenticated");
        }

        try {
          // List all calendars
          const response = await gapi.client.calendar.calendarList.list();
          const calendars = response.result.items || [];

          // Look for calendar with identifier in description (check all calendars)
          for (const cal of calendars) {
            try {
              // Fetch full calendar details to check description
              const fullCal = await gapi.client.calendar.calendars.get({
                calendarId: cal.id,
              });

              // Check if description contains our identifier
              const description = fullCal.result.description || "";
              if (description.includes(WORK_SLOTS_CALENDAR_IDENTIFIER)) {
                selectedCalendarId = cal.id;
                showToast("Using WorkSlots calendar");
                return cal.id;
              }
            } catch (err) {
              console.warn(`Could not fetch calendar ${cal.id} details:`, err);
              continue;
            }
          }

          // Not found - create a new calendar with identifier and boundary markers in description
          const initialDescription = `${WORK_SLOTS_DATA_START}\nWorkSlots Calendar - ID: ${WORK_SLOTS_CALENDAR_IDENTIFIER}\nSLOT_TYPES_JSON: []\n${WORK_SLOTS_DATA_END}`;
          const newCalendar = await gapi.client.calendar.calendars.insert({
            resource: {
              summary: WORK_SLOTS_CALENDAR_NAME,
              description: initialDescription,
            },
          });

          selectedCalendarId = newCalendar.result.id;
          showToast("Created WorkSlots calendar");
          return newCalendar.result.id;
        } catch (err) {
          console.error("Error finding/creating WorkSlots calendar:", err);
          throw err;
        }
      }

      async function loadSlotTypesFromCalendar(calendarId) {
        if (!calendarId) return null;

        try {
          const response = await gapi.client.calendar.calendars.get({
            calendarId: calendarId,
          });

          // Look for slot types within the boundary markers
          const description = response.result.description || "";
          const startIdx = description.indexOf(WORK_SLOTS_DATA_START);
          const endIdx = description.indexOf(WORK_SLOTS_DATA_END);

          if (startIdx === -1 || endIdx === -1 || startIdx >= endIdx) {
            return null;
          }

          // Extract content between boundaries
          const dataSection = description
            .substring(startIdx + WORK_SLOTS_DATA_START.length, endIdx)
            .trim();
          const slotTypesMatch = dataSection.match(
            /SLOT_TYPES_JSON:\s*(\[.*\]|\{.*\})/s,
          );

          if (slotTypesMatch) {
            try {
              const parsed = JSON.parse(slotTypesMatch[1]);
              return Array.isArray(parsed) ? parsed : null;
            } catch (parseErr) {
              console.error(
                "Error parsing slot types from description:",
                parseErr,
              );
              return null;
            }
          }

          return null;
        } catch (err) {
          console.error("Error loading slot types from calendar:", err);
          return null;
        }
      }

      async function saveSlotTypesToCalendar(calendarId, slotTypes) {
        if (!calendarId) {
          console.warn("No calendar ID provided for saving slot types");
          return false;
        }

        try {
          // Get current calendar to preserve user content outside boundaries
          const currentCal = await gapi.client.calendar.calendars.get({
            calendarId: calendarId,
          });

          const currentDesc = currentCal.result.description || "";

          // Extract user content before and after the boundary
          const startIdx = currentDesc.indexOf(WORK_SLOTS_DATA_START);
          const endIdx = currentDesc.indexOf(WORK_SLOTS_DATA_END);

          let beforeBoundary = "";
          let afterBoundary = "";

          if (startIdx !== -1 && endIdx !== -1 && startIdx < endIdx) {
            // Boundaries exist - extract user content
            beforeBoundary = currentDesc.substring(0, startIdx).trim();
            afterBoundary = currentDesc
              .substring(endIdx + WORK_SLOTS_DATA_END.length)
              .trim();
          } else {
            // No boundaries yet - check if there's existing content
            // If description contains the identifier, use everything before it as user content
            if (currentDesc.includes(WORK_SLOTS_CALENDAR_IDENTIFIER)) {
              const identifierIdx = currentDesc.indexOf(
                WORK_SLOTS_CALENDAR_IDENTIFIER,
              );
              beforeBoundary = currentDesc.substring(0, identifierIdx).trim();
              // Remove any old format data after identifier
              const afterIdentifier = currentDesc.substring(identifierIdx);
              const oldDataMatch =
                afterIdentifier.match(/SLOT_TYPES_JSON:.*$/s);
              if (oldDataMatch) {
                const oldDataEnd =
                  identifierIdx +
                  afterIdentifier.indexOf(oldDataMatch[0]) +
                  oldDataMatch[0].length;
                afterBoundary = currentDesc.substring(oldDataEnd).trim();
              }
            } else {
              // No identifier - preserve all existing content as user content
              beforeBoundary = currentDesc.trim();
            }
          }

          // Build new description with boundaries
          // Identifier is now inside the boundary section
          const dataSection = `WorkSlots Calendar - ID: ${WORK_SLOTS_CALENDAR_IDENTIFIER}\nSLOT_TYPES_JSON: ${JSON.stringify(slotTypes)}`;

          const parts = [];

          // Add user content before boundary
          if (beforeBoundary) {
            parts.push(beforeBoundary);
          }

          // Add app-managed section with boundaries (identifier is inside)
          parts.push(WORK_SLOTS_DATA_START);
          parts.push(dataSection);
          parts.push(WORK_SLOTS_DATA_END);

          // Add user content after boundary
          if (afterBoundary) {
            parts.push(afterBoundary);
          }

          const newDescription = parts.join("\n\n");

          await gapi.client.calendar.calendars.patch({
            calendarId: calendarId,
            resource: {
              description: newDescription,
            },
          });
          return true;
        } catch (err) {
          console.error("Error saving slot types to calendar:", err);
          showToast("Error saving slot types. Check console.");
          return false;
        }
      }

      function renderCalendar() {
        const grid = document.getElementById("calendarGrid");
        const display = document.getElementById("currentMonthDisplay");
        grid.innerHTML = "";

        const firstDay = new Date(currentYear, currentMonth, 1).getDay();
        const daysInMonth = new Date(
          currentYear,
          currentMonth + 1,
          0,
        ).getDate();

        const monthNames = [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
        ];
        display.innerText = `${monthNames[currentMonth]} ${currentYear}`;

        for (let i = 0; i < firstDay; i++) {
          const cell = document.createElement("div");
          cell.className = "day-cell bg-slate-50/50";
          grid.appendChild(cell);
        }

        for (let d = 1; d <= daysInMonth; d++) {
          const dateKey = `${currentYear}-${String(currentMonth + 1).padStart(2, "0")}-${String(d).padStart(2, "0")}`;
          const cell = document.createElement("div");
          cell.className = "day-cell p-2 cursor-pointer";
          cell.onclick = () => openAssignModal(dateKey, d);

          const dayNum = document.createElement("span");
          dayNum.className = "text-sm font-medium text-slate-500";
          dayNum.innerText = d;

          cell.appendChild(dayNum);

          if (schedule[dateKey]) {
            const slot = slotTypes.find((s) => s.id == schedule[dateKey]);
            if (slot) {
              const badge = document.createElement("div");
              badge.className = "slot-badge text-white";
              badge.style.backgroundColor = getSlotColorHex(slot);
              badge.innerText = `${slot.name} (${slot.start})`;
              cell.appendChild(badge);
            }
          }
          grid.appendChild(cell);
        }
      }

      function changeMonth(delta) {
        currentMonth += delta;
        if (currentMonth > 11) {
          currentMonth = 0;
          currentYear++;
        }
        if (currentMonth < 0) {
          currentMonth = 11;
          currentYear--;
        }
        renderCalendar();
        // Load slots from Google Calendar when month changes (if authenticated)
        if (gapi.client.getToken() && selectedCalendarId) {
          loadSlotsFromCalendar();
        }
      }

      function renderSlotTypes() {
        const list = document.getElementById("slotTypeList");
        list.innerHTML = "";
        slotTypes.forEach((slot) => {
          const div = document.createElement("div");
          div.className =
            "p-3 bg-slate-50 rounded-lg border border-slate-100 space-y-2";
          div.innerHTML = `
                    <div class="flex justify-between items-center">
                        <input type="text" value="${slot.name}" onchange="updateSlot(${slot.id}, 'name', this.value)" class="bg-transparent font-bold text-sm w-24 outline-none focus:text-indigo-600">
                        <button onclick="removeSlotType(${slot.id})" class="text-slate-400 hover:text-red-500">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        </button>
                    </div>
                    <div class="flex items-center gap-2 text-xs text-slate-500">
                        <input type="time" value="${slot.start}" onchange="updateSlot(${slot.id}, 'start', this.value)" class="bg-white border rounded px-1">
                        <span>to</span>
                        <input type="time" value="${slot.end}" onchange="updateSlot(${slot.id}, 'end', this.value)" class="bg-white border rounded px-1">
                    </div>
                    <div class="flex items-center gap-2 text-xs text-slate-500">
                        <span class="font-medium">Color</span>
                        <div class="relative inline-block color-picker-wrapper" data-color-picker="true">
                          <button
                            type="button"
                            class="w-6 h-6 rounded-full border border-slate-200 shadow-sm hover:border-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-300 disabled:opacity-50 disabled:cursor-not-allowed"
                            style="background-color: ${getSlotColorHex(slot)}"
                            onclick="toggleSlotColorPicker(${slot.id})"
                            ${googleEventColors ? "" : "disabled"}
                          ></button>
                          ${
                            !googleEventColors
                              ? `
                          <div class="color-tooltip">
                            Please log in to select colors
                          </div>
                          `
                              : ""
                          }
                          <div
                            id="slotColorMenu_${slot.id}"
                            class="hidden absolute top-full left-0 mt-1 p-2 bg-white border border-slate-200 rounded-xl shadow-xl z-50"
                            style="min-width: max-content;"
                          >
                            <div class="grid grid-cols-6 gap-2">
                              ${renderColorSwatches(slot.id, slot.colorId)}
                            </div>
                          </div>
                        </div>
                    </div>
                `;
          list.appendChild(div);
        });
      }

      async function addNewSlotType() {
        // Check if user is logged in
        if (!gapi.client.getToken()) {
          showToast("Please log in to create slot types");
          return;
        }

        // Check if calendar is available
        if (!selectedCalendarId) {
          showToast("Calendar not ready. Please try again.");
          return;
        }

        const id = Date.now();
        slotTypes.push({
          id,
          name: "New Slot",
          start: "09:00",
          end: "17:00",
          colorId: "1",
          color: "#6366f1",
        });
        renderSlotTypes();
        if (selectedCalendarId) {
          await saveSlotTypesToCalendar(selectedCalendarId, slotTypes);
        }
      }

      async function updateSlot(id, field, value) {
        const slot = slotTypes.find((s) => s.id === id);
        if (slot) {
          slot[field] = value;
          if (
            field === "colorId" &&
            googleEventColors?.[String(value)]?.background
          ) {
            // Keep legacy color updated for UI fallbacks.
            slot.color = googleEventColors[String(value)].background;
          }
        }
        renderSlotTypes();
        renderCalendar();
        if (selectedCalendarId) {
          await saveSlotTypesToCalendar(selectedCalendarId, slotTypes);
        }
      }

      async function removeSlotType(id) {
        slotTypes = slotTypes.filter((s) => s.id !== id);
        Object.keys(schedule).forEach((k) => {
          if (schedule[k] == id) delete schedule[k];
        });
        renderSlotTypes();
        renderCalendar();
        if (selectedCalendarId) {
          await saveSlotTypesToCalendar(selectedCalendarId, slotTypes);
        }
      }

      function openAssignModal(dateKey, dayNum) {
        // Check if user is authenticated first
        if (!gapi.client.getToken()) {
          showToast("Please log in first");
          return;
        }

        // Check if calendar is available
        if (!selectedCalendarId) {
          showToast("Calendar not ready. Please try again.");
          return;
        }

        selectedDate = dateKey;
        document.getElementById("modalTitle").innerText =
          `Assign Slot: ${dayNum} ${document.getElementById("currentMonthDisplay").innerText}`;
        const container = document.getElementById("modalSlotOptions");
        container.innerHTML = `<button onclick="assignSlot(null)" class="w-full text-left p-3 rounded-xl border border-slate-200 hover:bg-slate-50 text-sm font-medium transition-all">No Slot (Clear)</button>`;

        slotTypes.forEach((slot) => {
          const btn = document.createElement("button");
          btn.className =
            "w-full text-left p-3 rounded-xl border border-slate-200 hover:border-indigo-300 hover:bg-indigo-50 text-sm font-medium transition-all flex justify-between items-center";
          btn.onclick = () => assignSlot(slot.id);
          btn.innerHTML = `<span>${slot.name} <span class="text-slate-400 font-normal ml-2">${slot.start} - ${slot.end}</span></span><div class="w-3 h-3 rounded-full" style="background-color: ${getSlotColorHex(slot)}"></div>`;
          container.appendChild(btn);
        });
        document.getElementById("assignModal").classList.remove("hidden");
      }

      function closeModal() {
        document.getElementById("assignModal").classList.add("hidden");
      }

      function assignSlot(slotId) {
        if (slotId === null) delete schedule[selectedDate];
        else schedule[selectedDate] = slotId;
        // No longer storing in localStorage - schedule is only in memory until synced
        renderCalendar();
        closeModal();
      }

      function gapiLoaded() {
        gapi.load("client", initializeGapiClient);
      }

      async function initializeGapiClient() {
        await gapi.client.init({
          apiKey: API_KEY,
          discoveryDocs: [DISCOVERY_DOC],
        });
        gapiInited = true;
        checkBeforeStart();
      }

      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: "",
        });
        gisInited = true;
        checkBeforeStart();
      }

      function checkBeforeStart() {
        if (gapiInited && gisInited)
          document.getElementById("syncBtn").disabled = false;
      }

      function handleAuthClick() {
        tokenClient.callback = async (resp) => {
          if (resp.error !== undefined) throw resp;
          document.getElementById("authBtn").classList.add("hidden");
          document.getElementById("signOutBtn").classList.remove("hidden");
          showToast("Connected to Google!");

          try {
            // Find or create WorkSlots calendar
            await findOrCreateWorkSlotsCalendar();

            // Load slot types from calendar
            const loadedSlotTypes =
              await loadSlotTypesFromCalendar(selectedCalendarId);
            if (loadedSlotTypes && loadedSlotTypes.length > 0) {
              slotTypes = loadedSlotTypes;
              renderSlotTypes();
            }

            // Load event colors for color picker
            await loadEventColors();

            // Enable UI
            document.getElementById("refreshBtn").classList.remove("hidden");
            document.getElementById("refreshBtn").disabled = false;
            document.getElementById("syncBtn").disabled = false;
            document.getElementById("addSlotTypeBtn").disabled = false;

            // Load existing slots from calendar
            await loadSlotsFromCalendar();
          } catch (err) {
            console.error("Error during authentication setup:", err);
            showToast("Error setting up calendar. Check console.");
          }
        };
        if (gapi.client.getToken() === null)
          tokenClient.requestAccessToken({ prompt: "consent" });
        else tokenClient.requestAccessToken({ prompt: "" });
      }

      function handleSignoutClick() {
        const token = gapi.client.getToken();
        if (token !== null) {
          google.accounts.oauth2.revoke(token.access_token);
          gapi.client.setToken("");
          document.getElementById("authBtn").classList.remove("hidden");
          document.getElementById("signOutBtn").classList.add("hidden");
          document.getElementById("refreshBtn").classList.add("hidden");
          document.getElementById("syncBtn").disabled = true;
          document.getElementById("addSlotTypeBtn").disabled = true;
          selectedCalendarId = null;
          schedule = {}; // Clear schedule on sign out
          slotTypes = []; // Clear slot types on sign out
          googleEventColors = null;
          renderCalendar();
          renderSlotTypes();
          showToast("Signed out.");
        }
      }

      async function loadEventColors() {
        if (!gapi.client.getToken()) return;
        try {
          const resp = await gapi.client.calendar.colors.get();
          googleEventColors = resp?.result?.event || null;
          renderSlotTypes();
          renderCalendar();
        } catch (err) {
          console.error("Error loading event colors:", err);
          googleEventColors = null;
          renderSlotTypes();
        }
      }

      async function loadSlotsFromCalendar() {
        if (!gapi.client.getToken()) {
          showToast("Please log in first");
          return;
        }

        if (!selectedCalendarId) {
          showToast("Please select a calendar first");
          return;
        }

        showToast("Loading slots from Google Calendar...");

        try {
          // Calculate the date range for the current month
          const firstDay = new Date(currentYear, currentMonth, 1);
          const lastDay = new Date(currentYear, currentMonth + 1, 0);

          // Set timeMin to start of first day and timeMax to end of last day
          const timeMin = new Date(
            currentYear,
            currentMonth,
            1,
            0,
            0,
            0,
          ).toISOString();
          const timeMax = new Date(
            currentYear,
            currentMonth,
            lastDay.getDate(),
            23,
            59,
            59,
          ).toISOString();

          // Fetch all events for the current month
          const response = await gapi.client.calendar.events.list({
            calendarId: selectedCalendarId,
            timeMin: timeMin,
            timeMax: timeMax,
            privateExtendedProperty: WORK_SLOTS_PRIVATE_FILTER,
            singleEvents: true,
            orderBy: "startTime",
          });

          const events = response.result.items || [];

          // Clear current month's schedule
          const monthPrefix = `${currentYear}-${String(currentMonth + 1).padStart(2, "0")}`;
          Object.keys(schedule).forEach((key) => {
            if (key.startsWith(monthPrefix)) {
              delete schedule[key];
            }
          });

          // Process each event and match to slot types
          for (const event of events) {
            // Verify it's a WorkSlots event (ONLY this flag)
            const isWorkSlotsEvent =
              event.extendedProperties?.private?.workSlotsManaged ===
              WORK_SLOTS_MANAGED_VALUE;
            if (!isWorkSlotsEvent || !event.summary) {
              continue;
            }

            // Summary is the slot name
            const slotName = event.summary.trim();

            // Find matching slot type by name
            const slot = slotTypes.find((s) => s.name === slotName);
            if (!slot) {
              console.warn(
                `Slot type "${slotName}" not found in local slot types`,
              );
              continue;
            }

            // Extract date from event start time
            const startDateTime = event.start.dateTime || event.start.date;
            if (!startDateTime) continue;

            const eventDate = new Date(startDateTime);
            const dateKey = `${eventDate.getFullYear()}-${String(eventDate.getMonth() + 1).padStart(2, "0")}-${String(eventDate.getDate()).padStart(2, "0")}`;

            // Only add if it's in the current month
            if (dateKey.startsWith(monthPrefix)) {
              schedule[dateKey] = slot.id;
            }
          }

          renderCalendar();
          showToast("Slots loaded from Google Calendar!");
        } catch (err) {
          console.error("Error loading slots:", err);
          showToast("Error loading slots. Check console.");
        }
      }

      async function syncToCalendar() {
        if (!gapi.client.getToken()) {
          handleAuthClick();
          return;
        }

        if (!selectedCalendarId) {
          showToast("Calendar not ready. Please try again.");
          return;
        }

        showToast(`Syncing slots...`);

        try {
          const monthPrefix = `${currentYear}-${String(currentMonth + 1).padStart(2, "0")}`;
          const daysInMonth = new Date(
            currentYear,
            currentMonth + 1,
            0,
          ).getDate();

          // Fetch all WorkSlots-managed events in the month (single API call)
          const monthTimeMin = new Date(
            currentYear,
            currentMonth,
            1,
            0,
            0,
            0,
          ).toISOString();
          const monthTimeMax = new Date(
            currentYear,
            currentMonth,
            daysInMonth,
            23,
            59,
            59,
          ).toISOString();

          const monthEventsResp = await gapi.client.calendar.events.list({
            calendarId: selectedCalendarId,
            timeMin: monthTimeMin,
            timeMax: monthTimeMax,
            privateExtendedProperty: WORK_SLOTS_PRIVATE_FILTER,
            singleEvents: true,
            orderBy: "startTime",
          });

          const monthEvents = monthEventsResp.result.items || [];

          // Group managed events by day (YYYY-MM-DD)
          const existingByDateKey = {};
          for (const event of monthEvents) {
            const isWorkSlotsEvent =
              event.extendedProperties?.private?.workSlotsManaged ===
              WORK_SLOTS_MANAGED_VALUE;
            if (!isWorkSlotsEvent) continue;

            const startDateTime = event.start?.dateTime || event.start?.date;
            if (!startDateTime) continue;

            const eventDate = new Date(startDateTime);
            const dateKey = `${eventDate.getFullYear()}-${String(eventDate.getMonth() + 1).padStart(2, "0")}-${String(eventDate.getDate()).padStart(2, "0")}`;
            if (!dateKey.startsWith(monthPrefix)) continue;

            if (!existingByDateKey[dateKey]) existingByDateKey[dateKey] = [];
            existingByDateKey[dateKey].push(event);
          }

          // For each day of the month:
          // - If schedule has no slot: delete managed event(s) for that day (Clear behavior)
          // - If schedule has slot: delete managed event(s) then insert the selected slot
          for (let d = 1; d <= daysInMonth; d++) {
            const dateStr = `${currentYear}-${String(currentMonth + 1).padStart(2, "0")}-${String(d).padStart(2, "0")}`;

            const existing = existingByDateKey[dateStr] || [];
            for (const event of existing) {
              await gapi.client.calendar.events.delete({
                calendarId: selectedCalendarId,
                eventId: event.id,
              });
            }

            const slotId = schedule[dateStr];
            if (!slotId) {
              continue;
            }

            const slot = slotTypes.find((s) => s.id == slotId);
            if (!slot) continue;

            let startDate = new Date(dateStr + "T" + slot.start);
            let endDate = new Date(dateStr + "T" + slot.end);
            if (endDate <= startDate) endDate.setDate(endDate.getDate() + 1);

            const newEvent = {
              summary: `${slot.name}`,
              description: "Created via WorkSlots",
              ...(slot.colorId ? { colorId: String(slot.colorId) } : {}),
              start: {
                dateTime: startDate.toISOString(),
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
              },
              end: {
                dateTime: endDate.toISOString(),
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
              },
              extendedProperties: {
                private: {
                  workSlotsManaged: WORK_SLOTS_MANAGED_VALUE,
                },
              },
            };

            await gapi.client.calendar.events.insert({
              calendarId: selectedCalendarId,
              resource: newEvent,
            });
          }
          showToast("Month synced and updated!");
          // Reload slots from calendar to ensure display is accurate
          await loadSlotsFromCalendar();
        } catch (err) {
          console.error(err);
          showToast("Error syncing. Check console.");
        }
      }

      function showToast(msg) {
        const toast = document.getElementById("toast");
        document.getElementById("toastMessage").innerText = msg;
        toast.classList.remove("translate-y-20", "opacity-0");
        setTimeout(
          () => toast.classList.add("translate-y-20", "opacity-0"),
          3000,
        );
      }

      window.onload = () => {
        renderSlotTypes();
        renderCalendar();
        gapiLoaded();
        gisLoaded();
        document.addEventListener("click", (e) => {
          if (!e.target.closest('[data-color-picker="true"]')) {
            closeAllSlotColorPickers();
          }
        });

        // Check if user was previously authenticated and setup calendar
        // This will be called after gapi initializes if token exists
        setTimeout(async () => {
          if (gapi.client && gapi.client.getToken()) {
            try {
              // Find or create WorkSlots calendar
              await findOrCreateWorkSlotsCalendar();

              // Load slot types from calendar
              const loadedSlotTypes =
                await loadSlotTypesFromCalendar(selectedCalendarId);
              if (loadedSlotTypes && loadedSlotTypes.length > 0) {
                slotTypes = loadedSlotTypes;
                renderSlotTypes();
              }

              // Load event colors
              await loadEventColors();

              // Enable UI
              document.getElementById("refreshBtn").classList.remove("hidden");
              document.getElementById("refreshBtn").disabled = false;
              document.getElementById("syncBtn").disabled = false;
              document.getElementById("addSlotTypeBtn").disabled = false;
              document.getElementById("authBtn").classList.add("hidden");
              document.getElementById("signOutBtn").classList.remove("hidden");

              // Load existing slots from calendar
              await loadSlotsFromCalendar();
            } catch (err) {
              console.error("Error loading on page init:", err);
            }
          }
        }, 1000);
      };
    </script>
  </body>
</html>
